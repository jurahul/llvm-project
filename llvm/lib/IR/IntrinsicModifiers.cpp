//===- IntrinsicModifiers.cpp - LLVM Intrinsic Modifier Handling --*- C++
//-*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
//
//===----------------------------------------------------------------------===//

#include "llvm/IR/IntrinsicModifiers.h"
#include "llvm/IR/IntrinsicsNVPTX.h"
#include <tuple>

// Incorporate declarations generated by Intrinsics emitter.
#include "llvm/IR/IntrinsicModifiersGen.h"

using namespace llvm;
using namespace Intrinsic;

bool Intrinsic::HasModifiers(ID id) {
  // include impl generated by Intrinsic emitter.
  // This is backed by a Intrinsic emitter generated 1-bit table, similar to
  // Intrinsic::isOverloaded.
  // return false;
  return id == nvvm_float_op0 || id == nvvm_float_op1 || id == nvvm_float_op2;
}

std::pair<bool, unsigned> Intrinsic::GetModifierArgPosition(ID id) {
  switch (id) {
  case nvvm_float_op0:
    return {false, 2}; // 2 mod args at end.
  case nvvm_float_op1:
  case nvvm_float_op2:
    return {true, 1}; // 1 mod arg at start.
  default:
    llvm_unreachable("Called on intrinsic with no modifier args");
  }
}

// This function is generated entirely by the Intrinsic emitter. Or at least
// the switch cases inside it.
void llvm::Intrinsic::PrintModifiers(raw_ostream &OS, const IntrinsicInst &I) {
  Intrinsic::ID ID = I.getIntrinsicID();
  if (!HasModifiers(ID))
    return;
  switch (ID) {
  case nvvm_float_op0: {
    // This has 2 intrinsic operands, and they are at the end of the arg
    // list. So they are args 1 and 2.
    nvvm::FloatOp0Modifiers Mods;
    std::get<0>(Mods) = !cast<ConstantInt>(I.getArgOperand(1))->isZero();
    std::get<1>(Mods) = cast<ConstantInt>(I.getArgOperand(2))->getZExtValue();
    nvvm::printOp0Modifiers(OS, Mods);
    return;
  }
  case nvvm_float_op1: {
    // This has 1 intrinsic operand at the start of the arg list.
    nvvm::FloatOp1Modifiers Mods;
    Mods = cast<ConstantInt>(I.getArgOperand(0))->getZExtValue();
    nvvm::printOp1Modifiers(OS, Mods);
    return;
  }
  case nvvm_float_op2: {
    // This has 1 intrinsic operand at the start of the arg list.
    nvvm::FloatOp2Modifiers Mods;
    Mods = cast<ConstantInt>(I.getArgOperand(0))->getZExtValue();
    nvvm::printOp2Modifiers(OS, Mods);
    return;
  }

  default:
    llvm_unreachable("Intrinsic not handles in PrintIntrinsicModifiers");
  }
}

// Returns true if parsing failed.
bool llvm::Intrinsic::ParseModifiers(LLVMContext &Context, ID id,
                                     StringRef Suffix,
                                     SmallVectorImpl<ConstantInt *> &ModArgs) {
  switch (id) {
  case nvvm_float_op0: {
    nvvm::FloatOp0Modifiers Mods;
    // Strip the prefix name. This can potentially be done in lookupIntrinsicID.
    if (nvvm::parseOp0Modifiers(Suffix, Mods))
      return true;
    ModArgs.push_back(ConstantInt::getBool(Context, std::get<0>(Mods)));
    ModArgs.push_back(
        ConstantInt::get(IntegerType::get(Context, 16), std::get<1>(Mods)));
    return false; // Parsing successful.
  }
  case nvvm_float_op1: {
    nvvm::FloatOp1Modifiers Mods;
    if (nvvm::parseOp1Modifiers(Suffix, Mods))
      return true;
    ModArgs.push_back(ConstantInt::get(IntegerType::get(Context, 32), Mods));
    return false;
  }
  case nvvm_float_op2: {
    nvvm::FloatOp2Modifiers Mods;
    if (nvvm::parseOp2Modifiers(Suffix, Mods))
      return true;
    ModArgs.push_back(ConstantInt::get(IntegerType::get(Context, 32), Mods));
    return false;
  }
  default:
    llvm_unreachable("Intrinsic not handles in PrintIntrinsicModifiers");
  }
}